(define (cbrt x)
  (cbrt-iter 1.0 x))

(define (cbrt-iter guess x)
  (if (good-enough? guess x cube)
      guess
      (cbrt-iter (improve guess x) x)))

(define (good-enough? guess x f)
  (< (abs (- (f guess) x)) (* x 0.0000001)))

(define (improve guess x)
  (/ (+ (/ x (square guess)) (* 2 guess)) 3))

(cbrt 8.0)

					; lexical scoping

(define (square x) (* x x))
(define (average x y) (/ (+ x y) 2))

(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
	guess
	(sqrt-iter (improve guess))))
  (sqrt-iter 1.0))

(sqrt 4)

(define (factorial n)
  (define (fact-iter curr max acc)
    (if (> curr max)
	acc
	(fact-iter (+ curr 1) max (* acc curr))))
  (fact-iter 1 n 1))

(factorial 5)

(define (A x y)
  (cond ((= y 0) 0)
	((= x 0) (* 2 y))
	(( = y 1) 2)
	(else (A (- x 1) (A x (- y 1))))))

;; stopped at 1.2.2 Tree Recursion (pp. 47)

;; tree recursive procedure -- exponential
(define (fib n)
  (cond ((= n 0) 0)
	((= n 1) 1)
	(else (+ (fib (- n 1))
		 (fib (- n 2))))))

;; linear iteration -- linear
(define (fib n)
  (fib-iter 1 0  n)
  (define (fib-iter a b count)
    (if (= count 0)
	b
	(fib-iter (+ a b) b (- count 1)))))

;; consider the following problem:
;; How many different ways can we make change of $1.00, given
;; - half-dollars
;; - quarters
;; - dimes
;; - nickels
;; - pennies?

;; Let C(q,d) count the number of ways we can make change for
;; quantity q given denominations d.
;; C(q,()) = 0 for any q
;; C(0,xs) = 1 for any xs
;; C(q,xs) = 0 for any xs, q < 0
;; C(q,x:xs) = C(q,xs) + (q-x, x:xs)

;; The book suggests the following solution
(define (count-change amount) (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
	(( or (< amount 0) (= kinds-of-coins 0)) 0)
	(else (+ (cc amount
		     (- kinds-of-coins 1))
		 (cc (- amount
			(first-denomination
			 kinds-of-coins))
		     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
	((= kinds-of-coins 2) 5)
	((= kinds-of-coins 3) 10)
	((= kinds-of-coins 4) 25)
	((= kinds-of-coins 5) 50)))

;; Exercises
;; 1.11 A function f is defined by the rule that
;; f(n) = { n if n < 3.
;;          f(n-1) + 2f(n-2) + 3f(n-3) if n >= 3.
;; Write a procedure that computes f by means of a recursive process.
;; Write a procedure that computes f by means of a iterative process.

;; recursive
(define (f-rec n)
  (if (< n 3)
      n
      (+ (f-rec (- n 1)) (* 2 (f-rec (- n 2))) (* 3 (f-rec (- n 3))))))

;; iterative
;; explanation
;; There are four slots : a b c k
;; a holds f(k), b holds f(k-1), c holds f(k-3).
;; Update rule:
;; a <- a + 2b + 3c;
;; b <- a;
;; c <- b;
;; k <- k+1.
;; Iteration stops when k=n
(define (f-iter n)
  (define (f-loop a b c count)
    (if (= count n)
	a
	(f-loop (+ a (* 2 b) (* 3 c))
		a
		b
		(+ 1 count))))
  (if (< n 3)
      n
      (f-loop 2 1 0 2)))

;; 1.12 Write a procedure that computes elements of
;; Pascal's triangle by means of a recursive process.

; computes element in ith row, jth column of pascals triangle
(define (pascal i j)
  (cond ((= i j) 1)
        ((< i 0) 0)
	((< j 0) 0)
	(else (+ (pascal (- i 1) j) (pascal (- i 1) (- j 1))))))


;; 1.13 Prove that Fib(n) is the closest integer to
;; phi^n/sqrt(5), where phi = (1+sqrt(5))/2.

;; The steps are as follows:
;; 1. Use induction to show that
;; Fib(n) = (phi^n-psi^n)/sqrt(5),
;; where psi = (1-sqrt(5)/2
;; 2. Show that |Fib(n) - phi^n/2| < 1/2.

;; Next time: 1.2.3 orders of growth (pp. 54)

;; say that R(n) (cost of procedure of 'size' n) has order Theta(f(n))
;; if, for large enough n, the value of R(n) sits between k1f(n) and k2f(n)
;; Exercises
;; 1.14. What are the orders of growth of space and number of steps used by
;; this process as the amount to be changed increases?

;; 1.15
;; For |x| < 0.1, we consider sinx = x.
;; For larger |x|, we have
;; sinx = 3sin(x/3) - 4sin^3(x/3)

(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
;; a. How many times is the procedure p applied when (sine 12.15) is evaluated?
;; The number of times we can divide 12.15 by 3 until it is smaller than 0.1
;; 12.15/(3^4) = 0.15, 12.15/(3^5) = 0.05. Ans.: 5
;; ln(10*12.15)/ln(3) = 4.3691 (aprox.)
;; b. What is the order of growth in space and number of steps (as a function of a)
;; used by the process generated by the sine procedure when (sine a) is evaluated?
;; The complexity of both time and space is O(log(n)).

;; 1.2.4 Exponentiation

;; b^n = b*b^(n-1)
;; b^0 = 1
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))

;; Theta(n) steps and Theta(n) space
;; Linear iteration version
(define (expt b n)
  (expt-iter b n 1))
(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b (- counter 1) (* b product))))
;; Theta(n) steps and Theta(1) space
;; We can reduce the number of steps further when the exponents are powers of two:
;; b^(2k) = (b^k)^2
;; We formulate the rule
;; b^n = (b^(n/2))^2 if n is even,
;;     = b*b^(n-1)   if n is odd.
(define (fast-expt b n)
  (cond ((= n 0) 1)
	((even? n) (square (fast-expt b (/ n 2))))
	(else (* b (fast-expt b (- n 1))))))
(define (even? n)
  (= (remainder n 2) 0))
(define (square x)
  (* x x))
;; Theta(log n) steps and space - much much faster than Theta(n)

;; Exercise 1.16: Design a procedure that evolves an iterative exponentiation proces
;; that uses successive squaring and uses a logarithmic number of steps, as does
;; fast-expt.

(define (my-fast-expt b n)
  (fast-expt-iter 1 b n))

;; invariant: ab^n is unchanged from state to state
(define (fast-expt-iter a b n)
  (cond ((= n 0) a)
	((even? n) (fast-expt-iter a (square b) (/ n 2)))
	(else (fast-expt-iter (* a b) b (- n 1)))))
  
;; Exercise 1.17: We can perform integer multiplication by repeated addition.
;; Here is a multiplication procedure analogous to the expt procedure
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
;; This algorithm takes a number of steps that is linear in b.
;; Suppose we have, together with addition, operations double and halve
;; (that do exactly what you expect them to)
;; Using these, design a multiplication procedure analogous to fast-expt that uses a
;; logarithmic number of steps.

(define (double a) (+ a a))
(define (halve a) (/ a 2))

(define (* a b)
  (cond ((= b 0) 0)
	((even? b) (double (* a (halve b))))
	(else (+ a (* a (- b 1))))))

;; Exercise 1.18: Using the results of the previous 2 exercises, devise a procedure that
;; generates an iterative process for multiplying two integers in terms of adding, doubling,
;; and halving and uses a logarithmic number of steps

(define (double a) (+ a a))
(define (halve a) (/ a 2))
(define (even? a) (= (remainder a 2) 0))

(define (* a b)
  (mult-iter a b 0))

(define (mult-iter a b acc)
  (cond ((= b 0) acc)
	((even? b) (mult-iter (double a) (halve b) acc))
	(else (mult-iter a (- b 1) (+ acc a)))))

;; implement Russian peasant method
;; Next time: ex 1.19 pp.61

;; Exercise 1.19
;; Fibonacci T : a <- a + b, b <- a 
;; Applying T n times, starting with a=1, b=0, produces Fib(n+1) and Fib(n)
;; We can think of this transformation as a special case of p = 0, q = 1 in
;; a family of transformations Tpq, where Tpq transforms the pair (a,b)
;; according to a <- bq + aq + ap and b <- bp + aq.
;; The matrix of this transformation is
;; A = [(p+q) q; q p]
;; The problem is basically asking us to find A^2
;; A^2 = [((p+q)^2 + q^2) (2pq + q^2); (2pq + q^2) (p^2 + q^2)]
;; Therefore
;; p' = p^2 + q^2
;; q' = 2pq + q^2 = (p+q)^2 - p^2

(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
	((even? count)
	 (fib-iter a
		   b
		   (sum-of-squares p q)     ; p'
		   (+ (* 2 p q) (square q)) ; q'
		   (/ count 2)))
	(else (fib-iter (+ (* b q) (* a q) (* a p))
			(+ (* b p) (* a q))
			p
			q
			(- count 1)))))

(define (sum-of-squares a b)
  (+ (square a) (square b)))
(define (square a) (* a a))

;; 1.2.5 Greatest Common Divisors
;; Euclid's Algorithm
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

;; LamÃ©'s Theorem: If Euclid's Algorithm requires k steps to
;; compute the GCD of some pair, then the smallest number in
;; the pair must be greater than or equal to the kth Fibonacci
;; number.

;; We can use this theorem to get an order-of-growth estimate for Euclid's
;; Algorithm. Let n be the smaller of the two inputs in the procedure. If the
;; process takes k steps, then we must have
;; n >= Fib(k) approx phi^k/sqrt(5).
;; Therefore the number of steps k grows as the logarithm (base phi) of n.
;; Hence, the order of growth is Theta(log n)

;; Exercise 1.20 Illustrate the (gcd 206 40). How many remainder operations
;; are performed using
;; (a) normal-order evaluation
;; (b) applicative order evaluation
;;     -> 4


;; 1.2.6 Example: Testing for Primality

(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
	((divides? test-divisor n) test-divisor)
	(else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b) (= (remainder b a) 0))


;; The following primality test has order of growth Theta(sqrt(n))
;; (We only have to if n has a divisor up to sqrt(n))
(define (prime? n)
  (= n (smallest-divisor n)))

;; The Fermat Test
;; Fermat's Little Theorem: If n is a prime number and a
;; is any positive integer less than n, then a raised to the nth
;; power is congruent to a modulo n.

;; If n is not prime, then most of the numbers a<n will not satisfy the above relation.

;; Given a number n, pick a random number a < n and compute a^n mod n.
;; If the result is not equal to a, then n is certainly not prime.
;; If it is a, then chances are good that n is prime.
;; By successively trying more random values for a, we can become more and more certain
;; that n is prime.

;; The next procedure computes base^exp mod m
(define (expmod base exp m)
  (cond ((= exp 0) 1)
	((even? exp)
	 (remainder
	  (square (expmod base (/ exp 2) m))
	  m))
	(else
	 (remainder
	  (* base (expmod base (- exp 1) m))
	  m))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) true)
	((fermat-test n) (fast-prime? n (- times 1)))
	(else false)))

;; Fermat's algorithm is an example of a probabilistic algorithm.


;; Exercise 1.21: Use the smallest-divisor procedure to find the smallest
;; divisor of each of the following numbers: 199, 1999, 19999
(smallest-divisor 199)
(smallest-divisor 1999)
(smallest-divisor 19999)

;; Exercise 1.22

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

;; checks primality of consecutive odd integers in a specified range.
(define (search-for-primes min max)
  (cond ((= min max) ())
	((prime? min) (cons min (search-for-primes (+ 1 min) max)))
	(else (search-for-primes (+ 1 min) max))))

(define (n-smallest-primes n min start-time)
  (cond ((= n 0) (cons (- (runtime) start-time) ()))
	((prime? min) (cons min (n-smallest-primes (- n 1) (+ min 1) start-time)))
	(else (n-smallest-primes n (+ min 1) start-time))))

;; Exercise 1.23
;; We expect that this new test takes half as long as the previous prime test

(define (next n)
  (if (= n 2)
      3
      (+ n 2)))

(define (new-smallest-divisor n)
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
	  ((divides? test-divisor n) test-divisor)
	  (else (find-divisor n (next test-divisor)))))
  (define (divides? a b) (= (remainder b a) 0))
  (find-divisor n 2))

(define (new-prime? n)
  (= n (new-smallest-divisor n)))

(define (timed-new-prime-test n)
  (define (start-prime-test n start-time)
    (if (new-prime? n)
	(report-prime (- (runtime) start-time))))
  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))
  (newline)
  (display n)
  (start-prime-test n (runtime)))

;; Exercise 1.24

(define (timed-fast-prime-test n)
  (define (start-fast-prime-test n start-time)
    (if (fast-prime? n 10)
	(report-fast-prime (- (runtime) start-time))))
  (define (report-fast-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))
  (newline)
  (display n)
  (start-fast-prime-test n (runtime)))

;; Exercise 1.25:
;; She is correct - calling expmod again in applicative order
;; turns the complexity from Theta(log n) to Theta(n) by creating
;; procedures in a tree-like (exponential) fashion.

;; Exercise 1.26
;; Fermat's Little Theorem (Alternative)
;; If n is prime and a is any positive integer less than a, then
;; a^(n-1) == 1 (mod n)
;; Miller-Rabin test: Pick a random a < n and raise compute a^(n-1) mod n with expmod.
;; When performing the squaring step in expmod, check if a is a nontrivial square root of
;; 1 modulo n - that is, a number not equal to 1 or n-1 whose square is equal to 1 mod n.
;; If such nontrivial square root of 1 exists, then n is not prime.
;; Also, if n is an odd number that is not prime, the for at least half of the numbers
;; a < n, computing a^(n-1) in this way will reveal a nontrivial square root of 1 mod n.

;; NOTE: this doesn't work
(define (new-expmod base exp m)
  (cond ((= exp 0) 1)
	((even? exp)
	 (if (= (expmod base 2 m) 1) ;; check nontrivial sqrt of 1 mod n
	     0
	     (remainder
	      (square (new-expmod base (/ exp 2) m))
	      m)))
	(else
	 (remainder
	  (* base (expmod base (- exp 1) m))
	  m))))

(define (miller-rabin-test n)
  (define (try-it a)
    (= (new-expmod a (- n 1) n) 1))
  (try-it (+ 1 (random (- n 1)))))

(define (new-fast-prime? n times)
  (cond ((= times 0) true)
	((miller-rabin-test n) (new-fast-prime? n (- times 1)))
	(else false)))


;; 1.3 Formulating Abstractions with Higher-Order Procedures

(define (sum-integers a b)
  (if (> a b)
      0
      (+ a (sum-integers (+ a 1) b))))

(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a)
	 (sum-cubes (+ a 1) b))))

(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2)))
	 (pi-sum (+ a 4) b))))

;; All these three procedures are sums of some general term
;; We could generate each of the procedures by filling the slots in the same template

(define (<name> a b)
  (if (> a b)
      0
      (+ (<term> a)
	 (<name> (<next> a) b))))

;; We transform each slot in the template above into formal parameters to get

(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
	 (sum term (next a) next b))))

;; Now we can rewrite the previous procedures

(define (inc n) (+ n 1))
(define (identity x) x)
(define (cube a) (* a a a))

(define (sum-integers a b)
  (sum identity a inc b))

(define (sum-cubes a b)
  (sum cube a inc b))

(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))

;; Our abstraction can be used to formulate further concepts.
;; Integrals can be approximated numerically with the following formula
;; int_a^b f = [f(a+dx/2) + f(a + dx + dx/2) + f(a + 2dx + dx/2) + ...]dx
;; using a small value for dx.

(define (integral f a b dx)
  (define (add-dx x)
    (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))

;; Exercise 1.29
;; Simpson's Rule: The integral of f between a and b is approximated as
;; (h/3)(y0 + 4y1 + 2y2 + 4y3 + 2y4 + ... + 2y[n-2] + 4y[n-1] + yn)
;; where
;;     h = (b-a)/n,
;;     yk = f(a+kh).
;; Define a procedure that takes arguments f, a, b, and n and returns the value
;; of the integral computed using Simpson's Rule.

(define (s-integral f a b n)
  (define h (/ (- b a) n))
  (define (sy k) (f (+ a (* k h))))
  (define (term k) (+ (* 4 (sy k)) (* 2 (sy (+ k 1)))))
  (define (next k) (+ k 2))
  (* (/ h 3.0)
     (+ (sy 0)
	(sy n)
	(* 4 (sy (- n 1)))
	(sum term 1 next (- n 1)))))

;; Exercise 1.30
;; Rewrite sum so that the sum is performed iteratively

(define (sum-iter term a next b)
  (define (iter a result)
    (if (> a b)
	result
	(iter (next a) (+ result (term a)))))
  (iter a 0))

;; Exercise 1.31
;; Write a procedure product analogous to sum that returns the product of the
;; values of a function at points over a given range. Also use product to
;; compute approximations of pi using the formula
;; pi/4 = (2*4*4*6*6*8...)/(3*3*5*5*7*7*...)

(define (prod-iter term a next b)
  (define (iter a result)
    (if (> a b)
	result
	(iter (next a) (* result (term a)))))
  (iter a 1))

(define (prod-rec term a next b)
  (if (> a b)
      1
      (* (term a)
	 (prod-rec term (next a) next b))))

(define (pi-approx n)
  (define (term x) (/ (square (+ x 1)) (square x)))
  (define (next x) (+ x 2))
  (* 8.0
     (prod-iter term 3 next n)))

;; Exercise 1.32
;; Show that sum and product are both special cases of a still more general
;; notion called accumulate that combines a colection of terms, using some
;; general accumulation function.

(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
	result
	(iter (next a) (combiner a result))))
  (iter a null-value))

(define (accumulate-rec combiner null-value term a next b)
  (if (> a b)
      null-term
      (combiner (term a)
		(accumulate-rec combiner null-value term (next a) next b))))

;; Exercise 1.33 (Wait there's more)
;; Show that accumulate can be generalized still by introducing a notion of a filter.
;; Write a filtered-accumulate function, then express the following using filtered-
;; accumulate:
;; a. the sum of the squares of prime numbers in the interval a to b (assuming that
;; you have a prime? predicate already written
;; b. the product of all the positive integers less than n that are relatively prime
;; to n

(define (filtered-accumulate-rec predicate combiner null-value term a next b)
  (define curr
    (if (predicate a)
	(term a)
	null-value))
  (if ((> a b)
       null-value)
       (combiner curr
		 (filtered-accumulate-rec
		  predicate combiner null-value term (next a) next b))))

(define (filtered-accumulate predicate combiner null-value term a next b)
  (define (curr x)
    (if (predicate x)
	(term x)
	null-value))
  (define (iter a result)
    (if (> a b)
	result
	(iter (next a) (combiner (curr a) result))))
  (iter a null-value))

;; (a)
(filtered-accumulate prime? + 0 square a inc b)
;; (b)
(define (rel-prime a)
  (= (gcd a n) 1))
(filtered-accumulate rel-prime? * 1 identity 1 inc n)

;; next: 1.3.2 Constructing Procedures Using lambda (pp. 83)

;; 1.3.3 Procedures as General Methods
;; Finding roots of equations by the half-interval method
(define (search f neg-point pos-point)
  (let ((midpoint (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
	midpoint
	(let ((test-value (f midpoint)))
	  (cond ((positive? test-value)
		 (search f neg-point midpoint))
		((negative? test-value)
		 (search f midpoint pos-point))
		(else midpoint))))))

(define (close-enough? x y) (< (abs (- x y)) 0.001))

(define (half-interval-method f a b)
  (let ((a-value (f a))
	(b-value (f b)))
    (cond ((and (negative? a-value) (positive? b-value))
	   (search f a b))
	  ((and (negative? b-value) (positive? a-value))
	   (search f b a))
	  (else
	   (error "Values are not of opposite sign" a b)))))

;; Finding fixed points of functions
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
	  next
	  (try next))))
  (try first-guess))

;; We can think of finding square roots of x as finding y such that
;; y^2 = x,
;; or equivalently
;; y = x/y.
(define (sqrt x)
  (fixed-point (lambda (y) (/ x y))
	       1.0))
;; This method, however, does not always converge.
;; The solution is to reduce the range of oscillation from one guess to the next
(define (sqrt x)
  (fixed-point (lambda (y) (average y (/ x y)))
	       1.0))
;; This averaging approach is called average damping, and it often aids the convergence
;; of fixed point searches.

;; Exercise 1.35: Show that the golden ratio phi is a fixed point of the transformation
;; x |-> 1 + 1/x, and use this fact to compute phi by means of the fixed-point procedure.

;; Suppose x0 is a fixed point of the transformation. Then
;; x0 = 1 + 1/x0 -> x0^2 = x0 + 1 -> x0^2 - x - 1 = 0.
;; The two solution to the equations are
;; (1-sqrt(5))/2, (1+sqrt(5))/2,
;; the second of which is phi.

(define phi (fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0))

;; Exercise 1.36: Modify the fixed-point procedure so that it prints the
;; sequence of approximations it generates, using the newline and display
;; primitives. Then find a solution to x^x = 1000 by finding a fixed point
;; of x |-> log(1000)/log(x).
;; Compare the number of steps this takes with and without average damping.
;; Note: don't use starting point of 1.0 (division by log(1) = 0).

(define (tabular-fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
	  next
	  (try next))))
  (try first-guess))

;; No avg damping - around 30 iterations
(tabular-fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0)

;; With avg damping - around 8 iterations
(tabular-fixed-point (lambda (x) (average x (/ (log 1000) (log x))))
		     2.0)

;; Exercise 1.37
;; ni/(di+acc)
(define (cont-frac n d k)
  (define (iter i acc)
    (if (= i 0)
	acc
	(iter (- i 1)
	      (/ (n i) (+ (d i) acc)))))
  (iter k 1))

;; Exercise 1.38
;; e - 2 approximated by a continued fraction
;; Ni are all 1
;;        0 1 2 3 4 5 6 7 8 9 10
;; Di are 1,2,1,1,4,1,1,6,1,1,8,...
;; Use cont-frac to approximate e.

;; look at this dude
(define (d-e i)
  (cond ((= i 1) 1)
	((= i 2) 2)
	((= i 3) 1)
	((= i 4) 1)
	((= i 5) 4)
	((= i 6) 1)
	((= i 7) 1)
	((= i 8) 6)
	((= i 9) 1)
	((= i 10) 1)
	((= i 11) 8)))
(define e-approx (+ 2 (cont-frac (lambda (i) 1.0) d-e 10)))

;; Exercise 1.39

(define (tan-cf x k)
  (define (n i)
    (if (= i 1)
	x
	(- (* x x))))
  (define (d i)
    (- (* 2 i) 1))
  (cont-frac n d k))

;; 1.3.4 Procedures as Returned Values

(define (average-damp f)
  (lambda (x) (average x (f x))))

;; abstractions make our ideas much clearer
;; notet that this is the same procedure as the first square root procedure shown in the book.

(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
	       1.0))

(define (cube-root x)
  (fixed-point (average-damp (lambda (y) (/ x (square y))))
	       1.0))

;; Newton's method
;; If g(x) is a differentiable function, the solution to g(x)=0 is
;; a fixed point of the function x |-> f(x), where
;; f(x) = x - g(x)/(Dg(x))
;; where Dg(x) is the derivative of g evaluated at x.
;; We can think of the derivative as a procedure that yields a function given another
;; function as input
;; From the difference quotient we get

(define (deriv g)
  (define dx 0.0001)
  (lambda (x) (/ ( - (g (+ x dx)) (g x)) dx)))

(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))
(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))

(define (sqrt x)
  (newtons-method
   (lambda (y) (- (square y) x)) 1.0))

;; Abstractions and first-class procedures
(define (fixed-point-of-transform g transform guess)
  (fixed-point (transform g) guess))

;; sqrt as fixed point of y |-> x/y
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (/ x y)) average-damp 1.0))

;; sqrt as fixed point of y |-> y^2 - x
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (- (square y) x)) newton-transform 1.0))

;; Exercise 1.40: Define a procedure cubic that can be used together with the newtons-method
;; procedure in expressions of the form
;; (newtons-method (cubic a b c) 1)
;; to approximate zeros of the cubic x^3 + ax^2 + bx + c

(define (cubic a b c)
  (lambda (x) (+ (* x x x) (* a x x) (* b x) c)))

;; example
(newtons-method (cubic -10 2 -22) 1)
;; should return around 10.2

;; Exercise 1.41: Define a procedure double that takes a procedure of one argument
;; and returns a procedure that applies the original procedure twice.
;; What value is returned by
(((double (double double)) inc) 5)
;; ans.: 21
(define (double f) (lambda (x) (f (f x))))

;; Exercise 1.42: Define a procedure that implements function composition of two
;; one-argument functions
(define (compose f g)
  (lambda (x) (f (g x))))

;; Exercise 1.43: Write a procedure that takes as inputs a procedure that computes
;; f and a positive integer n and returns the procedure that computes the nth repeated
;; aplication of f.

(define (repeated f n)
  (if (= n 0)
      (lambda (x) x)
      (lambda (x) (f ((repeated f (- n 1)) x)))))
((repeated square 2) 5)

;; using compose

(define (repeated f n)
  (if (= n 0)
      (lambda (x) x)
      (lambda (x) ((compose f (repeated f (- n 1))) x))))

;; Exercise 1.44: If f is a function and dx is some small number, then the smoothed
;; version of f is the function whose value at a point x is the average of f(x-dx),
;; f(x), and f(x+dx), Write a procedure smooth that takes as input a procedure that
;; computes f and returns a procedure that computes the smoothed f. Also, show how
;; to generate the n-fold smoothed function of any given function using smooth
;; and repeated.

(define (smooth f)
  (define dx 0.000001)
  (lambda (x) (/ (+ (f x) (f (- x dx)) (f (+ x dx))) 3)))

(define (n-smooth f n)
  ((repeated smooth n) f))

;; Exercise 1.45: A simple average damp is not enough to make a fixed-point search for
;; y |-> x/y^3 converge (fourth root search). On the other hand, if we average damp twice,
;; the fixed-point search does converge. Do some experiments to determine how many
;; average damps are required to compute nth roots as fixed point search based upon
;; repeated average damping of y |-> x/y^(n-1). Use this to implement a simple procedure
;; for computing nth roots using fixed-point, average-damp, and the repeated procedure.
;; Assume that any arithmetic operations you need are available as primitives.


(define (lg n x)
  (/ (log x) (log n)))

(define (average-damp f)
  (lambda (x) (average x (f x))))

(define (nth-root n x)
  (fixed-point-of-transform
   (lambda (y) (/ x (fast-expt y (- n 1)))) (repeated average-damp (floor (lg 2 n))) 1.0))

(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (/ x y)) average-damp 1.0))

;; Exercise 1.46:
;; Iterative improvement
;;  - start with an initial guess
;;  - test if the guess is good enough
;;  - if not, improve the guess and repeat
;; iterative-improve takes two arguments
;;  - a method of telling whether a guess is good enough
;;  - a method for improving the guess
;; and returns a procedure that takes a guess as argument and keeps improving
;; the guess until it is good enough.

(define (iterative-improve good-enough? improve)
  (define (proc guess)
    (if (good-enough? guess)
	guess
	(proc (improve guess))))
  (lambda (guess)
    (proc guess)))

(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (* guess guess) x)) tolerance))
  (define (improve guess)
    (average guess (/ x guess)))
  ((iterative-improve good-enough? improve) 1.0))

;; 2 Building Abstractions with Data

(define (linear-combination a b x y)
  (+ (* a x) (* b y)))

;; This works fine for numbers, but what about other fields?

(define (linear-combination a b x y)
  (add (mul a x) (mul by)))

;; here mul and add may or may not be the primitive * and + for numeric arguments.

;; We now see how we can 'glue' together data objects to form compound data objects.

;; 2.1 Introduction to Data Abstraction

;; 2.1.1 Example: Arithmetic Operations on Rational Numbers

;; Assume that we already have a way of constructing rational numbers.
;; Assume also that we have procedures for extracting (or selecting) the components of
;; rational numbers, the numerator and the denominator.
;; Let us further assume that the constructor and selectors are available as procedures.
;; (make-rat <n> <d>)
;; (numer <x>)
;; (denom <x>)

;; We now express the rules of rational arithmetic as procedures

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
	       (* (numer y) (denom x)))
	    (* (denom x) (denom y))))

(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
	       (* (numer y) (denom x)))
	    (* (denom x) (denom y))))

(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
	    (* (denom x) (denom y))))

(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
	    (* (denom x) (numer y))))

(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))

;; Now, to actually define make-rat, num, and denom
;; There are two ways to go about this
(define (make-rat n d) (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))

;; or

(define make-rat cons)
(define numer cat)
(define denom cdr)
;; The only difference is in programming style

;; So our rational numbers are just lists of two elements.
;; It is also nice to have a way of displaying our rational numbers

(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

;; Now to try our rational-number procedures

(define one-half (make-rat 1 2))
(print-rat one-half)
;; 1/2
(define one-third (make-rat 1 3))
(print-rat (add-rat one-half one-third))
;; 5/6
(print-rat (mul-rat one-half one-third))
;; 1/6
(print-rat (add-rat one-third one-third))
;; 6/9

;; The current make-rat procedure does not reduce the fraction to its lowest terms.
;; We can modify it to do so using gcd.

(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))

(print-rat (add-rat one-third one-third))
;; 2/3

;; Exercise 2.1: Define a better version of make-rat that handles both positive
;; and negative arguments.

(define (make-rat n d)
  (if (or (and (< n 0) (< d 0))
	  (and (> n 0) (< d 0)))
      (make-rat (- n) (- d))
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g)))))

;; 2.1.2 Abstraction Barriers

;; Exercise 2.2:

(define (make-segment start end)
  (cons start end))

(define (start-segment seg)
  (car seg))

(define (end-segment seg)
  (cdr seg))

(define (make-point x y)
  (cons x y))

(define (x-point p)
  (car p))

(define (y-point p)
  (cdr p))

(define (midpoint-segment seg)
  (let ((start (start-segment seg))
	(end (end-segment seg))
	(x0 (x-point start))
	(x1 (x-point end))
	(y0 (y-point start))
	(y1 (y-point end)))
    (make-point (/ (+ x1 x0) 2)
		(/ (+ y1 y0) 2))))

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))

(define start (make-point 0 0))
(define end (make-point 2 4))
(define segment (make-segment start end))
(define mid (midpoint-segment segment))
(print-point mid)
;; (1,2)

	
;; Exercise 2.3: Implement a representation of rectangles on a plane

;; point is bottom left corner of rectangle
;; all selectors assume width, height are positive
(define (make-rect point width height)
  `(,point ,width ,height))

(define (corners-rect rect)
  (let ((w (cadr rect))
	(h (caddr rect))
	(x (x-point (car rect)))
	(y (y-point (car rect))))
  `(,(make-point x y)
    ,(make-point x (+ y h))
    ,(make-point (+ x w) (+ y h))
    ,(make-point (+ x w) y))))

(define (bottom-left-rect rect)
  (car (corners-rect rect)))
(define (top-left-rect rect)
  (cadr (corners-rect rect)))
(define (top-right-rect rect)
  (caddr (corners-rect rect)))
(define (bottom-right-rect rect)
  (cadddr (corners-rect rect)))

(define (perimeter-rect rect)
  (let ((bl (bottom-left-rect rect))
	(tl (top-left-rect rect))
	(br (bottom-right-rect rect)))
    (* 2 (+ (- (y-point tl) (y-point bl))
	    (- (x-point br) (x-point bl))))))

(define (area-rect rect)
  (let ((bl (bottom-left-rect rect))
	(tl (top-left-rect rect))
	(br (bottom-right-rect rect)))
    (* (- (y-point tl) (y-point bl))
       (- (x-point br) (x-point bl)))))
         

;; 2.1.3 What Is Means by Data?

;; We can implement cons, car, and cdr using only procedures and no data structures.
(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
	  ((= m 1) y)
	  (else (error "Argument not 0 or 1: CONS" m))))
  dispatch)

(define (car z) (z 0))
(define (cdr z) (z 1))

;; This is a completely valid implementation.
;; (car (cons x y)) -> x
;; (cdr (cons x y)) -> y

;; Exercise 2.4: Here is an alternative procedural representation of pairs.
;; For this representation, verify that (car (cons x y)) yields x for any
;; objects x and y.

(define (cons x y)
  (lambda (m) (m x y))) ;; takes a function and appield it to two arguments
(define (car z)
  (z (lambda (p q) p)))
(define (cdr z)
  (z (lambda (p q) q)))

;; My substitution:
;; (car (cons x y)) -> (car (lambda (m) (m x y)))
;;                  -> ((lambda (m) (m x y)) (lambda (p q) p))
;;                  -> ((lambda (p q) p) x y)
;;                  -> x

;; Exercise 2.5: Show that we can represent pairs of nonnegative integers using only
;; numbers and arithmetic operations if we represent the pair a and b as the integer
;; that is the product (2^a)*(3^b). Give the corresponding definitions of the procedures
;; cons, car, and cdr.

(define (cons-num x y) (* (fast-expt 2 x) (fast-expt 3 y)))
(define (car-num z)
  (if (= (remainder z 2) 0)
      (+ 1 (car-num (/ z 2)))
      0))
(define (cdr-num z)
  (if (= (remainder z 3) 0)
      (+ 1 (car-num (/ z 3)))
      0))
      
;; Exercise 2.6: In a language that can manipulate procedures, we can get by without
;; numbers (at least insofar as nonnegative integers are concerned) by implementing
;; 0 and the operation of adding 1 as

(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))

;; Define one and two directly (not in terms of zero and add-1).

(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))

;; 2.1.4 Extended Exercise: Interval Arithmetic

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
		 (+ (upper-bound x) (upper-bound y))))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
	(p2 (* (lower-bound x) (upper-bound y)))
	(p3 (* (upper-bound x) (lower-bound y)))
	(p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
		   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (mul-interval
   x
   (make-interval (/ 1.0 (upper-bound y))
		  (/ 1.0 (lower-bound y)))))

;; Exercise 2.7

(define (make-interval a b) (cons a b))

(define (lower-bound x) (car x))
(define (upper-bound x) (cdr x))

;; Exercise 2.8
(define (sub-interval x y)
  (add-interval
   x
   (make-interval (- (upper-bound y))
		  (- (lower-bound y)))))

;; Exercise 2.9
;; Width of interval: (1/2)(x1 - x0)
;; Show that the width of the sum (or difference) of two intervals is a function
;; only of the widths of the intervals being added (or subtracted)
;; Give examples to show that this is not true for multiplication or division.

;; Let I1 = [x0,x1] and I2 = [y0,y1] be two intervals. Their sum is I = [x0+y0,x1+y1].
;; The width of I is
;; (1/2)((x1+y1) - (x0+y0)) = (1/2)((x1-x0) + (y1-y0))
;;                          = (1/2)(x1-x0) + (1/2)(y1-y0)
;; which is the sum of the widths of the two intervals.

;; Since interval subtraction is defined in terms of interval addition, it is easy
;; to see that the widths of the difference of two intervals is a function only
;; of the widths of the intervals being subtracted.

;; Suppose I1 = [0,1] and I2 = [1,2]. Then I1*I2 = [0,2]. If f: RXR -> R is the function
;; that indicates the width of the product of two intervals, then f(1,1) = 2.
;; But I1*I1 = [0,1], which would say that f(1,1) = 1. Therefore there is no such f.
;; A counterexample for division is analogous.

;; Exercise 2.10

(define (div-interval x y)
  (let ((y0 (lower-bound y))
	(y1 (upper-bound y)))
    (if (< (* y0 y1) 0)
	(make-error)
	(mul-interval
	 x
	 (make-interval (/ 1.0 y1)
			(/ 1.0 y0))))))

;; Exercise 2.11

;; no idea rn
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
	(p2 (* (lower-bound x) (upper-bound y)))
	(p3 (* (upper-bound x) (lower-bound y)))
	(p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
		   (max p1 p2 p3 p4))))
;; Exercise 2.12

(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define (make-center-percent c p)
  (let ((delta (/ (* c p) 100.0)))
    (make-interval (- c delta)
		   (+ c delta))))

(define (percent i)
  (let ((c (center i))
	(delta (/ (- (upper-bound i) (lower-bound i)) 2.0)))
    (* 100 (/ delta c))))

;; Exercise 2.13: Show that under the assumption of small percentage tolerances
;; there is a simple formula for the approximate percentage tolerance of the
;; product of two intervals in terms of the tolerances of the factors.

;; Intuitively, the product of two small errors is really small, so given two intervals
;; x = x0 +- dx,
;; y = y0 +- dy,
;; We end up with the approximations
;; xy ~ x0y0 +- (x0dy y0dx),
;; assuming that all numbers are positive.

;; Exercise 2.14

;; Two equivalent formulas for computing parallel resistance give different results.
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
		(add-interval r1 r2)))

(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval
     one (add-interval (div-interval one r1)
		       (div-interval one r2)))))

(define int-1 (make-center-percent 100 0.0001))
(define int-2 (make-center-percent 50 0.0001))
(define div (div-interval int-1 int-2))
(center div)
;; -> 2.000000000004
(percent div)
;; -> 2.0000000000535112e-4

(define one (div-interval int-1 int-1))
(center one)
;; -> 1.000000000002
(percent one)
;; -> 2.0000000000535112e-4

;; Succession of arithmetic operations on floating point numbers increase the error.

;; Exercise 2.15
;; She is right - not repeating uncertain numbers is a good rule of thumb to reduce
;; the number of successive floating-point operations.

;; Exercise 2.16: see 2.14

;; 2.2 Hierarchical Data and the Closure Property
